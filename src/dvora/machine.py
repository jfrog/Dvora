import struct

import attr
from elftools.elf.elffile import ELFFile

from dvora.exceptions import UnimplementedArchitecture

ENDIANESSE_TO_STRUCT_ENDIANESSE = {"little": "<", "big": ">"}

WORD_SIZE_TO_STRUCT_FMT = {8: "B", 16: "H", 32: "I", 64: "Q"}


def make_fmt(endianness: str, bit_width: int) -> str:
    return (
        ENDIANESSE_TO_STRUCT_ENDIANESSE[endianness] + WORD_SIZE_TO_STRUCT_FMT[bit_width]
    )


@attr.s(auto_attribs=True)
class Machine:
    """Encapsulates the low level properties of a machine.

    Things like word size, endianness and implementation of signed numbers (and in
    the future, floating point).
    """

    #: Name of the architecture (e.g. "arm")
    name: str
    #: Name of the register used as a stack pointer ("sp", "rsp", ...)
    sp_name: str
    #: Name of the register used as a program counter ("pc", "rip", ...")
    pc_name: str
    #: Number of bits in the machine's word (8/16/32/64)
    bit_width: int
    #: Machine endianness ("little", "big")
    endianness: str
    #: Autogenerated ``struct``'s format for the machine's word
    fmt: str = attr.ib(
        default=attr.Factory(
            lambda self: make_fmt(self.endianness, self.bit_width), takes_self=True
        ),
        init=False,
    )

    @property
    def sizeof_word(self) -> int:
        """Number of bytes in the machine's word"""
        return self.bit_width // 8

    def signed(self, value: int) -> int:
        """Cast an unsigned value to the machine's signed.

        E.g. on a 32bit machine, ``0xffffffff`` will be cast to ``-1``

        Args:
            value: The (unsigned) number to convert

        Returns:
            The number cast to signed

        """
        if (value & (1 << (self.bit_width - 1))) != 0:
            return value - (1 << self.bit_width)
        return value

    def unsigned(self, value: int) -> int:
        """Cast a signed value to an unsigned.

        E.g. on a 32bit machine, ``-1`` will be cast to ``0xffffffff``

        Args:
            value: The (signed) number to convert

        Returns:
            The number cast to unsigned

        """
        if value < 0:
            return value + (1 << self.bit_width)
        return value

    def pack_word(self, value: int) -> bytes:
        """Encode an unsigned value into the machine's word.
        This takes into account the machine's word size and endianness.

        Args:
            value: The (unsigned) number to encode

        Returns:
            A ``bytes`` object representing the encoded number

        """
        return struct.pack(self.fmt, value)

    def unpack_word(self, value: bytes) -> int:
        """Decode an unsigned value from a machine's word.
        This takes into account the machine's word size and endianness.

        Args:
            value: An ``bytes`` object representing the encoded value

        Returns:
            An unsigned number

        """
        (result,) = struct.unpack(self.fmt, value)
        return int(result)


def arm(endianness: str) -> Machine:
    return Machine(
        name="arm",
        sp_name="SP",
        pc_name="PC",
        bit_width=32,
        endianness=endianness,
    )


def x86_64(endianness: str) -> Machine:
    return Machine(
        name="x86_64",
        sp_name="RSP",
        pc_name="RIP",
        bit_width=64,
        endianness=endianness,
    )


def aarch64(endianness: str) -> Machine:
    return Machine(
        name="aarch64",
        sp_name="SP",
        pc_name="PC",
        bit_width=64,
        endianness=endianness,
    )


def x86(endianness: str) -> Machine:
    return Machine(
        name="x86",
        sp_name="ESP",
        pc_name="EIP",
        bit_width=32,
        endianness=endianness,
    )


def mips(endianness: str) -> Machine:
    return Machine(
        name="mips",
        sp_name="SP",
        pc_name="PC",
        bit_width=32,
        endianness=endianness,
    )


EI_DATA_TO_ENDIANESSE = {"ELFDATA2LSB": "little", "ELFDATA2MSB": "big"}

E_MACHINE_TO_MACHINE = {
    "EM_ARM": arm,
    "EM_IA_64": x86_64,
    "EM_X86_64": x86_64,
    "EM_AARCH64": aarch64,
    "EM_386": x86,
    "EM_MIPS": mips,
}


def machine_from_elf(filename: str) -> Machine:
    """Recover a ``Machine`` object from an ELF.

    Args:
        filename: Path to an ELF file

    Returns:
        A ``Machine`` object that represent that target of the ELF

    """
    with open(filename, "rb") as fp:
        elf = ELFFile(fp)
        e_machine = elf.header["e_machine"]
        machine_constructor = E_MACHINE_TO_MACHINE.get(e_machine, None)
        if machine_constructor:
            ei_data = elf.header["e_ident"]["EI_DATA"]
            endianness = EI_DATA_TO_ENDIANESSE.get(ei_data, None)
            if endianness:
                return machine_constructor(endianness)
        raise UnimplementedArchitecture(e_machine)
